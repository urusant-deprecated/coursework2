% Описание задачи на основании данных: построить импликации по данным, + модификации алгоритма под эту задачу
\section{Обучение импликациям на основе данных}
\subsection{Постановка задачи}
В реальной жизни в качестве оракула обычно выступает человек или группа людей, обладающих экспертными знаниями в некоторой области. Однако, во многих случаях доступа к таким людям может не быть по ряду причин. Например, мы можем не обладать полными знаниями о некоторой области, или нахождение этих знаний является слишком долгим в связи с малым количеством экспертов. Однако, мы можем иметь некоторые данные о примерах объектов, о которых пытаемся что-то выучить. В связи с этим появляется задача обучения по выборке. Формально, пусть у нас есть набор объектов $X$, у каждого из которых есть некоторое количество бинарных признаков.

\begin{definition}
Замыкание $X$ - это множество $a = x_1 \land x_2 \land \dots \land x_k, x_i \in X$, то есть множество всевозможных пересечений объектов из $X$.
\end{definition}

Тогда наша задача состоит в нахождении множества импликаций, которому удовлетворяют в точности все объекты из замыкания.

Чтобы применить уже известный алгоритм к такой постановке задачи, нужно описать, как выполняются запросы принадлежности (отметим, что запросы эквивалентности мы уже умеем моделировать через запросы принадлежности, соответственно, их не требуется моделировать снова).

По сути запрос принадлежности заключается в проверке того, что заданный объект $x$ является пересечением некоторого подмножества $X'$ имеющихся объектов. Заметим, что все элементы из $X'$ должны иметь все признаки, которые есть у $x$. Тогда возьмем множество $X''$ всех объектов, содержащих все признаки $x$. Тогда пересечение всех элементов $X''$, очевидно, содержит все признаки из $x$. Кроме того, если существует множество $X'$, пересечение элементов которого равно $x$, то пересечение элементов $X'' \supseteq X'$ тоже равно $x$. Значит, достаточно проверить, что пересечение всех множеств, содержащих $x$, равно $x$.

\subsection{Оптимизации алгоритма}
\subsubsection{Ограничение по времени}
Поскольку теоретическая оценка на качество довольно грубая, можно предположить, что на практике заданное качество достигается значительно быстрее, чем в момент сходимости. Тогда логично попробовать чем-то ограничить время рандомизированному алгоритму. Это можно сделать двумы способами. Во-первых, можно просто задать некоторый константный порог. Это имеет смысл, поскольку часто алгоритм работает достаточно медленно. Кроме того, для задачи построения импликаций по данным уже существуют точные алгоритмы, которые подробно описаны в [2]. Поэтому логично попробовать ограничить рандомизированный алгоритм некоторой долей времени работы какого-нибудь из них.

\subsection{Использование данных для более точного корректирования импликаций}
\emph{Coming soon}

\subsection{Использование замыкания}
Напомним, что в рандомизированном оракуле мы генерируем случайные объекты, а затем проверяем, являются ли они контрпримерами. Заметим, что при условии использования оптимизации из предыдущего пункта мы уверены, что если контрпример есть, то он отрицательный. Значит, он точно должен удовлетворять нашим импликациям. Тем не менее, многие из сгенерированных объектов не будут удовлетворять этим свойством. Чтобы исправить это, можно замыкать каждый генерируемый объект относительно нашего текущего множества импликаций. Тогда полученный объект достаточно будет проверить на принадлежность соответствующим запросом к оракулу. Тем не менее, замыкание - это довольно сложная операция, поэтому следует ожидать ухудшения производительности (или качество - если мы ограничиваем время).