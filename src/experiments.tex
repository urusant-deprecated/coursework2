\section{Тестирование}

Для тестирования удобно использовать как раз постановку задачи на основе данных. При этом можно использовать как сгенерированные модельные примеры, так и реальные данные. Начнем с первых. Будем генерировать выборку случайно. При этом будем задавать количество признаков и объектов, а также плотность, то есть вероятность появления отдельно заданного признака у заданного объекта. Кроме того, мы можем задавать параметры нашего алгоритма, а именно, $\epsilon, \delta$, а также использовать различные варианты оптимизаций.

Теперь нужно ввести метрики качества. Во-первых, логично измерять качество работы алгоритма, поскольку он не является точным. В качестве метрики качества можно использовать ту величину, для которой мы гарантируем теоретическую оценку. Поскольку объектов экспоненциально много, честный расчет этой величины занимает очень много времени, поэтому будем использовать рандомизированную оценку этой величины: возьмем 10000 случайных объектов, проверим, сколько из них входят в числитель, и усредним размером выборки.

Теперь вернемся к тому, зачем мы вообще хотим обучаться импликациям. В большой степени это необходимо с целью имитации оператора замыкания. Это означает, что для произвольного набора признаков мы хотим понимать, какими еще признаками обладает объект, обладающий этими. Тогда естественной метрикой будет доля объектов, для которых мы правильно определяем замыкание. Ее тоже можно считать рандомизированно: возьмем выборку из 1000 случайных объектов и проверим, для скольких из них замыкание на основе наших импликаций совпадает с замыканием на основе реальных импликаций, и также усредним размером выборки.

Теперь разберемся с параметрами алгоритма. В первую очередь посмотрим на оптимизации. Eсть 3 основных версии алгоритма:

\begin{enumerate}
	\item Базовый алгоритм. Эта версия не использует никаких оптимизаций, кроме, возможно, ограничения по времени.
	\item Улучшенный алгоритм. Эта версия использует оптимизацию 2 из предыдущей секции для задачи на основе данных.
	\item Улучшенный алгоритм с улучшенным оракулом. Эта версия использует обе оптимизации 2 и 3 из предыдущей секции. Отметим, что оптимизация 3 частично основана на гарантиях, предоставляемых оптимизацией 2, и, соответственно, имеет мало смысла без нее.
\end{enumerate}

Кроме того, используем первую оптимизацию следующим образом: возьмем из [2] оптимизированный алгоритм Гантера с использованием линейного замыкания, и ограничим половиной времени его работы наш алгоритм.

Посмотрим на зависимости качества работы алгоритмов от параметров выборки. Ниже приведены графики зависимости 2х метрик, о которых говорилось выше, от одного из параметров выборки при фиксированных двух оставшихся. Здесь guaranteed metric - это метрика, теоретическая оценка на которую гарантируется в оригинальной версии алгоритма, а quality - доля ошибок оператора замыкания.

\includegraphics[scale=0.3]{img/obj-accuracy}
\includegraphics[scale=0.3]{img/obj-quality}

\includegraphics[scale=0.3]{img/attr-accuracy}
\includegraphics[scale=0.3]{img/attr-quality}

\includegraphics[scale=0.3]{img/dens-accuracy}
\includegraphics[scale=0.3]{img/dens-quality}

Как можно видеть, лучшим качеством обладает оригинальный алгоритм. Это, вероятно, происходит потому, что оптимизации хоть и потенциально улучшают качество, значительно ухудшают производительность алгоритма, и поэтому в условиях ограниченного времени не успевают достичь требуемого качества.

\emph{Coming soon}
% Эксперименты для оригинального алгоритма
% Описание оптимизации с getconsequence
% Эксперименты с getconsequence
% Описание оптимизации с closure
% Эксперименты с closure
% Описание оптимизации "обрезать время"
% Эксперименты с обрезанием времени
% Эксперименты: время работы на реальных данных