\section{Тестирование}

Для тестирования удобно использовать как раз постановку задачи на основе данных. При этом можно использовать как сгенерированные модельные примеры, так и реальные данные. Начнем с первых. Будем генерировать выборку случайно. При этом будем задавать количество признаков и объектов, а также плотность, то есть вероятность появления отдельно заданного признака у заданного объекта. Кроме того, мы можем задавать параметры нашего алгоритма, а именно, $\epsilon, \delta$.

Теперь нужно ввести метрики качества. Во-первых, будем измерять время работы алгоритма. Однако, поскольку мы самостоятельно имитируем оракул, и для разных выборок его вызовы могут работать разное время, имеет смысл также считать, сколько раз мы вызываем те или иные запросы к оракулу.

Далее, логично измерять качество работы алгоритма, поскольку он не является точным. В качестве метрики качества можно использовать ту величину, для которой мы гарантируем теоретическую оценку. Поскольку объектов экспоненциально много, честный расчет этой величины занимает очень много времени, поэтому будем использовать рандомизированную оценку этой величины: возьмем 10000 случайных объектов, проверим, сколько из них входят в числитель, и усредним размером выборки.

Теперь вернемся к тому, зачем мы вообще хотим обучаться импликациям. В большой степени это необходимо с целью имитации оператора замыкания. Это означает, что для произвольного набора признаков мы хотим понимать, какими еще признаками обладает объект, обладающий этими. Тогда естественной метрикой будет доля объектов, для которых мы правильно определяем замыкание. Ее тоже можно считать рандомизированно: возьмем выборку из 1000 случайных объектов и проверим, для скольких из них замыкание на основе наших импликаций совпадает с замыканием на основе реальных импликаций, и также усредним размером выборки.

Кроме того, отметим, что поскольку алгоритм рандомизированный, имеет смысл запустить его несколько раз и усреднить результат. В данном случае количество запусков равно %TODO.
\emph{Coming soon}
% Эксперименты для оригинального алгоритма
% Описание оптимизации с getconsequence
% Эксперименты с getconsequence
% Описание оптимизации с closure
% Эксперименты с closure
% Описание оптимизации "обрезать время"
% Эксперименты с обрезанием времени
% Эксперименты: время работы на реальных данных